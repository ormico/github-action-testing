name: Cleanup Old Artifacts

on:
  schedule:
    # Run cleanup every Sunday at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      cleanup_previews:
        description: 'Cleanup preview releases older than X days'
        required: false
        default: '7'
        type: string
      cleanup_artifacts:
        description: 'Cleanup workflow artifacts older than X days'
        required: false
        default: '30'
        type: string
      cleanup_images:
        description: 'Cleanup container images older than X days'
        required: false
        default: '90'
        type: string
      dry_run:
        description: 'Perform dry run (no actual deletions)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io

jobs:
  cleanup-preview-releases:
    name: Cleanup Preview Releases
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup preview container images
        shell: pwsh
        run: |
          $daysOld = [int]"${{ inputs.cleanup_previews || '7' }}"
          $dryRun = "${{ inputs.dry_run }}" -eq "true"
          $cutoffDate = (Get-Date).AddDays(-$daysOld)
          
          Write-Host "üßπ Cleaning up preview images older than $daysOld days (cutoff: $cutoffDate)"
          if ($dryRun) { Write-Host "DRY RUN MODE - No actual deletions will be performed" }
          
          # This would use GitHub API or registry API to list and delete old preview images
          # For now, this is a placeholder
          
          Write-Host "Querying container registry for preview images..."
          Write-Host "Repository: ${{ github.repository_owner }}/simpleweatherlist.web"
          Write-Host "Registry: ${{ env.REGISTRY }}"
          
          # Example cleanup logic (would need actual API calls)
          $previewImages = @(
              @{ tag = "1.0.0-preview-abc123-01"; created = (Get-Date).AddDays(-10) },
              @{ tag = "1.0.0-preview-def456-02"; created = (Get-Date).AddDays(-5) },
              @{ tag = "1.0.0-preview-ghi789-01"; created = (Get-Date).AddDays(-2) }
          )
          
          $imagesToDelete = $previewImages | Where-Object { $_.created -lt $cutoffDate -and $_.tag -like "*preview*" }
          
          if ($imagesToDelete.Count -eq 0) {
              Write-Host "‚úÖ No preview images found that need cleanup"
          } else {
              Write-Host "Found $($imagesToDelete.Count) preview images to cleanup:"
              foreach ($image in $imagesToDelete) {
                  Write-Host "  - $($image.tag) (created: $($image.created))"
                  if (-not $dryRun) {
                      Write-Host "    [Would delete image here]"
                      # gh api --method DELETE /user/packages/container/simpleweatherlist.web/versions/$version_id
                  }
              }
              
              if ($dryRun) {
                  Write-Host "DRY RUN: $($imagesToDelete.Count) images would be deleted"
              } else {
                  Write-Host "‚úÖ Cleaned up $($imagesToDelete.Count) preview images"
              }
          }

  cleanup-workflow-artifacts:
    name: Cleanup Workflow Artifacts
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup old workflow artifacts
        uses: actions/github-script@v6
        with:
          script: |
            const daysOld = parseInt("${{ inputs.cleanup_artifacts || '30' }}");
            const dryRun = "${{ inputs.dry_run }}" === "true";
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysOld);
            
            console.log(`üßπ Cleaning up workflow artifacts older than ${daysOld} days`);
            console.log(`Cutoff date: ${cutoffDate.toISOString()}`);
            if (dryRun) console.log("DRY RUN MODE - No actual deletions will be performed");
            
            try {
              // List all artifacts
              const artifacts = await github.rest.actions.listArtifactsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              console.log(`Found ${artifacts.data.artifacts.length} total artifacts`);
              
              // Filter artifacts older than cutoff date
              const oldArtifacts = artifacts.data.artifacts.filter(artifact => {
                const createdAt = new Date(artifact.created_at);
                return createdAt < cutoffDate;
              });
              
              console.log(`Found ${oldArtifacts.length} artifacts to cleanup`);
              
              if (oldArtifacts.length === 0) {
                console.log("‚úÖ No artifacts found that need cleanup");
                return;
              }
              
              let deletedCount = 0;
              for (const artifact of oldArtifacts) {
                console.log(`Processing: ${artifact.name} (created: ${artifact.created_at})`);
                
                if (!dryRun) {
                  try {
                    await github.rest.actions.deleteArtifact({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      artifact_id: artifact.id
                    });
                    deletedCount++;
                    console.log(`  ‚úÖ Deleted artifact: ${artifact.name}`);
                  } catch (error) {
                    console.log(`  ‚ùå Failed to delete artifact: ${artifact.name} - ${error.message}`);
                  }
                } else {
                  console.log(`  [DRY RUN] Would delete: ${artifact.name}`);
                  deletedCount++;
                }
              }
              
              if (dryRun) {
                console.log(`DRY RUN: ${deletedCount} artifacts would be deleted`);
              } else {
                console.log(`‚úÖ Cleaned up ${deletedCount} workflow artifacts`);
              }
              
            } catch (error) {
              console.error(`‚ùå Error during cleanup: ${error.message}`);
              throw error;
            }

  cleanup-container-images:
    name: Cleanup Old Container Images
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup old container images
        shell: pwsh
        run: |
          $daysOld = [int]"${{ inputs.cleanup_images || '90' }}"
          $dryRun = "${{ inputs.dry_run }}" -eq "true"
          $cutoffDate = (Get-Date).AddDays(-$daysOld)
          
          Write-Host "üßπ Cleaning up container images older than $daysOld days (cutoff: $cutoffDate)"
          if ($dryRun) { Write-Host "DRY RUN MODE - No actual deletions will be performed" }
          
          Write-Host "Repository: ${{ github.repository_owner }}/simpleweatherlist.web"
          Write-Host "Registry: ${{ env.REGISTRY }}"
          
          # This would use GitHub Packages API to manage container images
          # For now, this is a placeholder showing the approach
          
          # Example: Query for old non-latest, non-release images
          $allImages = @(
              @{ tag = "1.0.0.100"; created = (Get-Date).AddDays(-100); type = "release" },
              @{ tag = "1.0.1.101"; created = (Get-Date).AddDays(-50); type = "release" },
              @{ tag = "1.0.2.102"; created = (Get-Date).AddDays(-10); type = "release" },
              @{ tag = "latest"; created = (Get-Date).AddDays(-1); type = "latest" },
              @{ tag = "v1.0.0.100"; created = (Get-Date).AddDays(-100); type = "release-tag" }
          )
          
          # Don't delete latest or recent releases
          $imagesToDelete = $allImages | Where-Object { 
              $_.created -lt $cutoffDate -and 
              $_.type -ne "latest" -and 
              $_.tag -notlike "*preview*"  # Preview images handled separately
          }
          
          if ($imagesToDelete.Count -eq 0) {
              Write-Host "‚úÖ No old container images found that need cleanup"
          } else {
              Write-Host "Found $($imagesToDelete.Count) old images to cleanup:"
              foreach ($image in $imagesToDelete) {
                  Write-Host "  - $($image.tag) (created: $($image.created), type: $($image.type))"
                  if (-not $dryRun) {
                      Write-Host "    [Would delete image here via GitHub Packages API]"
                  }
              }
              
              if ($dryRun) {
                  Write-Host "DRY RUN: $($imagesToDelete.Count) images would be deleted"
              } else {
                  Write-Host "‚úÖ Cleaned up $($imagesToDelete.Count) old container images"
              }
          }

  cleanup-old-branches:
    name: Cleanup Merged Feature Branches
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cleanup merged feature branches
        shell: pwsh
        run: |
          $dryRun = "${{ inputs.dry_run }}" -eq "true"
          $daysOld = 30  # Keep branches for 30 days after merge
          $cutoffDate = (Get-Date).AddDays(-$daysOld)
          
          Write-Host "üßπ Cleaning up merged feature branches older than $daysOld days"
          if ($dryRun) { Write-Host "DRY RUN MODE - No actual deletions will be performed" }
          
          # Get all remote branches
          git fetch --all --prune
          $allBranches = git branch -r --format="%(refname:short)|%(objectname)|%(committerdate:iso)" | 
                        Where-Object { $_ -and $_ -notmatch "origin/(main|HEAD)" }
          
          $branchesToDelete = @()
          
          foreach ($branchInfo in $allBranches) {
              if (-not $branchInfo) { continue }
              
              $parts = $branchInfo -split '\|'
              if ($parts.Count -ne 3) { continue }
              
              $branchName = $parts[0]
              $commitHash = $parts[1]
              $commitDate = [DateTime]::Parse($parts[2])
              
              # Only consider feature and bug branches
              if ($branchName -match "origin/(feature|bug)/") {
                  # Check if branch is merged into main
                  $mergeBase = git merge-base $branchName origin/main 2>$null
                  $branchHead = git rev-parse $branchName 2>$null
                  
                  if ($mergeBase -eq $branchHead -and $commitDate -lt $cutoffDate) {
                      $branchesToDelete += @{
                          name = $branchName -replace "origin/", ""
                          commitDate = $commitDate
                          merged = $true
                      }
                  }
              }
          }
          
          if ($branchesToDelete.Count -eq 0) {
              Write-Host "‚úÖ No merged feature branches found that need cleanup"
          } else {
              Write-Host "Found $($branchesToDelete.Count) merged branches to cleanup:"
              foreach ($branch in $branchesToDelete) {
                  Write-Host "  - $($branch.name) (last commit: $($branch.commitDate))"
                  if (-not $dryRun) {
                      try {
                          git push origin --delete $branch.name
                          Write-Host "    ‚úÖ Deleted branch: $($branch.name)"
                      } catch {
                          Write-Host "    ‚ùå Failed to delete branch: $($branch.name)"
                      }
                  }
              }
              
              if ($dryRun) {
                  Write-Host "DRY RUN: $($branchesToDelete.Count) branches would be deleted"
              }
          }

  cleanup-summary:
    name: Cleanup Summary
    runs-on: ubuntu-latest
    needs: [cleanup-preview-releases, cleanup-workflow-artifacts, cleanup-container-images, cleanup-old-branches]
    if: always()
    steps:
      - name: Generate cleanup summary
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            const previewResult = "${{ needs.cleanup-preview-releases.result }}";
            const artifactsResult = "${{ needs.cleanup-workflow-artifacts.result }}";
            const imagesResult = "${{ needs.cleanup-container-images.result }}";
            const branchesResult = "${{ needs.cleanup-old-branches.result }}";
            const dryRun = "${{ inputs.dry_run }}" === "true";
            
            const getEmoji = (result) => {
              if (result === 'success') return '‚úÖ';
              if (result === 'failure') return '‚ùå';
              if (result === 'skipped') return '‚è≠Ô∏è';
              return '‚ö†Ô∏è';
            };
            
            let summary = `# üßπ Cleanup Results\n\n`;
            if (dryRun) {
              summary += `**Mode:** DRY RUN (no actual deletions performed)\n\n`;
            }
            
            summary += `## Cleanup Tasks\n\n`;
            summary += `| Task | Status |\n`;
            summary += `|------|--------|\n`;
            summary += `| Preview Releases | ${getEmoji(previewResult)} ${previewResult} |\n`;
            summary += `| Workflow Artifacts | ${getEmoji(artifactsResult)} ${artifactsResult} |\n`;
            summary += `| Container Images | ${getEmoji(imagesResult)} ${imagesResult} |\n`;
            summary += `| Merged Branches | ${getEmoji(branchesResult)} ${branchesResult} |\n`;
            
            summary += `\n## Configuration\n\n`;
            summary += `- **Preview releases older than:** ${{ inputs.cleanup_previews || '7' }} days\n`;
            summary += `- **Workflow artifacts older than:** ${{ inputs.cleanup_artifacts || '30' }} days\n`;
            summary += `- **Container images older than:** ${{ inputs.cleanup_images || '90' }} days\n`;
            summary += `- **Merged branches older than:** 30 days\n`;
            
            summary += `\n**Workflow Run:** [\`${{ github.run_id }}\`](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\n`;
            
            // Write to GitHub Step Summary
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
            
            console.log("Cleanup Summary:");
            console.log(summary);
